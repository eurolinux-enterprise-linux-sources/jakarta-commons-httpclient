From f99e7d4f68adde4b290ad6ab891a601ac6e58a1a Mon Sep 17 00:00:00 2001
From: Michal Srb <msrb@redhat.com>
Date: Tue, 12 Aug 2014 16:14:06 +0200
Subject: [PATCH] Fix CVE-2014-3577

Upstream fixed this vulnerability by taking advantage of JDK's javax.naming API.
We build this project using GCJ which doesn't provide all needed javax.naming
classes, so we need to use different implementation of DN parser.
Imlementation used in this patch comes from Android project [1] and it's licensed
under ASL 2.0.

[1]: https://platform--frameworks--base.android-source-browsing.googlecode.com/git-history/e46145f7c114b9ac6d19c6a7886e9239463f91e1/common/java/com/android/common/DNParser.java
---
 NOTICE                                             |   6 +
 .../protocol/SSLProtocolSocketFactory.java         | 486 ++++++++++++++++++++-
 .../org/apache/commons/httpclient/TestAll.java     |   2 +
 .../protocol/TestSSLProtocolSocketFactory.java     |  51 +++
 4 files changed, 522 insertions(+), 23 deletions(-)
 create mode 100644 src/test/org/apache/commons/httpclient/protocol/TestSSLProtocolSocketFactory.java

diff --git a/NOTICE b/NOTICE
index 152a780..d4d48bc 100644
--- a/NOTICE
+++ b/NOTICE
@@ -3,3 +3,9 @@ Copyright 1999-2007 The Apache Software Foundation
 
 This product includes software developed by
 The Apache Software Foundation (http://www.apache.org/).
+
+Android Code
+Copyright 2005-2008 The Android Open Source Project
+
+This product includes software developed as part of
+The Android Open Source Project (http://source.android.com).
diff --git a/src/java/org/apache/commons/httpclient/protocol/SSLProtocolSocketFactory.java b/src/java/org/apache/commons/httpclient/protocol/SSLProtocolSocketFactory.java
index fa0acc7..539e200 100644
--- a/src/java/org/apache/commons/httpclient/protocol/SSLProtocolSocketFactory.java
+++ b/src/java/org/apache/commons/httpclient/protocol/SSLProtocolSocketFactory.java
@@ -44,7 +44,6 @@ import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Locale;
-import java.util.StringTokenizer;
 import java.util.regex.Pattern;
 
 import javax.net.ssl.SSLException;
@@ -424,30 +423,26 @@ public class SSLProtocolSocketFactory implements SecureProtocolSocketFactory {
 		return dots;
 	}
 
-	private static String getCN(X509Certificate cert) {
-        // Note:  toString() seems to do a better job than getName()
-        //
-        // For example, getName() gives me this:
-        // 1.2.840.113549.1.9.1=#16166a756c6975736461766965734063756362632e636f6d
-        //
-        // whereas toString() gives me this:
-        // EMAILADDRESS=juliusdavies@cucbc.com        
-		String subjectPrincipal = cert.getSubjectX500Principal().toString();
-		
-		return getCN(subjectPrincipal);
-
+	private static String getCN(final X509Certificate cert) {
+		final String subjectPrincipal = cert.getSubjectX500Principal().toString();
+		try {
+			return extractCN(subjectPrincipal);
+		} catch (SSLException ex) {
+			return null;
+		}
 	}
-	private static String getCN(String subjectPrincipal) {
-		StringTokenizer st = new StringTokenizer(subjectPrincipal, ",");
-		while(st.hasMoreTokens()) {
-			String tok = st.nextToken().trim();
-			if (tok.length() > 3) {
-				if (tok.substring(0, 3).equalsIgnoreCase("CN=")) {
-					return tok.substring(3);
-				}
-			}
+
+	private static String extractCN(final String subjectPrincipal) throws SSLException {
+		if (subjectPrincipal == null) {
+			return null;
+		}
+		try {
+			DNParser dnp = new DNParser(subjectPrincipal);
+			// return null or actual CN value
+			return dnp.find("cn");
+		} catch (IOException e) {
+			throw new SSLException(subjectPrincipal + " is not a valid X500 distinguished name");
 		}
-		return null;
 	}
 
     /**
@@ -464,4 +459,449 @@ public class SSLProtocolSocketFactory implements SecureProtocolSocketFactory {
         return getClass().hashCode();
     }    
     
+
+    /*
+     * Taken from Android project:
+     * https://platform--frameworks--base.android-source-browsing.googlecode.com/git-history/e46145f7c114b9ac6d19c6a7886e9239463f91e1/common/java/com/android/common/DNParser.java
+     * Licensed under ASL 2.0
+     */
+
+    /*
+     *  Licensed to the Apache Software Foundation (ASF) under one or more
+     *  contributor license agreements.  See the NOTICE file distributed with
+     *  this work for additional information regarding copyright ownership.
+     *  The ASF licenses this file to You under the Apache License, Version 2.0
+     *  (the "License"); you may not use this file except in compliance with
+     *  the License.  You may obtain a copy of the License at
+     *
+     *     http://www.apache.org/licenses/LICENSE-2.0
+     *
+     *  Unless required by applicable law or agreed to in writing, software
+     *  distributed under the License is distributed on an "AS IS" BASIS,
+     *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     *  See the License for the specific language governing permissions and
+     *  limitations under the License.
+     */
+
+    /*
+     * A simple distinguished name(DN) parser.
+     *
+     * <p>This class is based on org.apache.harmony.security.x509.DNParser.  It's customized to remove
+     * external references which are unnecessary for our requirements.
+     *
+     * <p>This class is only meant for extracting a string value from a DN.  e.g. it doesn't support
+     * values in the hex-string style.
+     */
+    private static final class DNParser {
+        /** DN to be parsed. */
+        private final String dn;
+
+        // length of distinguished name string
+        private final int length;
+
+        private int pos, beg, end;
+
+        // tmp vars to store positions of the currently parsed item
+        private int cur;
+
+        // distinguished name chars
+        private char[] chars;
+
+        /*
+         * Exception message thrown when we failed to parse DN
+         */
+        private static final String ERROR_PARSE_ERROR = "Failed to parse DN";
+
+        /*
+         * Constructor.
+         *
+         * @param principal
+         *            - {@link java.lang.String} to be parsed
+         */
+        public DNParser(String principal) {
+            this.dn = principal;
+            this.length = dn.length();
+        }
+
+        // gets next attribute type: (ALPHA 1*keychar) / oid
+        private String nextAT() throws IOException {
+
+            // skip preceding space chars, they can present after
+            // comma or semicolon (compatibility with RFC 1779)
+            for (; pos < length && chars[pos] == ' '; pos++) {
+            }
+            if (pos == length) {
+                return null; // reached the end of DN
+            }
+
+            // mark the beginning of attribute type
+            beg = pos;
+
+            // attribute type chars
+            pos++;
+            for (; pos < length && chars[pos] != '=' && chars[pos] != ' '; pos++) {
+                // we don't follow exact BNF syntax here:
+                // accept any char except space and '='
+            }
+            if (pos >= length) {
+                // unexpected end of DN
+                throw new IOException(ERROR_PARSE_ERROR);
+            }
+
+            // mark the end of attribute type
+            end = pos;
+
+            // skip trailing space chars between attribute type and '='
+            // (compatibility with RFC 1779)
+            if (chars[pos] == ' ') {
+                for (; pos < length && chars[pos] != '=' && chars[pos] == ' '; pos++) {
+                }
+
+                if (chars[pos] != '=' || pos == length) {
+                    // unexpected end of DN
+                    throw new IOException(ERROR_PARSE_ERROR);
+                }
+            }
+
+            pos++; // skip '=' char
+
+            // skip space chars between '=' and attribute value
+            // (compatibility with RFC 1779)
+            for (; pos < length && chars[pos] == ' '; pos++) {
+            }
+
+            // in case of oid attribute type skip its prefix: "oid." or "OID."
+            // (compatibility with RFC 1779)
+            if ((end - beg > 4) && (chars[beg + 3] == '.')
+                    && (chars[beg] == 'O' || chars[beg] == 'o')
+                    && (chars[beg + 1] == 'I' || chars[beg + 1] == 'i')
+                    && (chars[beg + 2] == 'D' || chars[beg + 2] == 'd')) {
+                beg += 4;
+            }
+
+            return new String(chars, beg, end - beg);
+        }
+
+        // gets quoted attribute value: QUOTATION *( quotechar / pair )
+        // QUOTATION
+        private String quotedAV() throws IOException {
+
+            pos++;
+            beg = pos;
+            end = beg;
+            while (true) {
+
+                if (pos == length) {
+                    // unexpected end of DN
+                    throw new IOException(ERROR_PARSE_ERROR);
+                }
+
+                if (chars[pos] == '"') {
+                    // enclosing quotation was found
+                    pos++;
+                    break;
+                } else if (chars[pos] == '\\') {
+                    chars[end] = getEscaped();
+                } else {
+                    // shift char: required for string with escaped chars
+                    chars[end] = chars[pos];
+                }
+                pos++;
+                end++;
+            }
+
+            // skip trailing space chars before comma or semicolon.
+            // (compatibility with RFC 1779)
+            for (; pos < length && chars[pos] == ' '; pos++) {
+            }
+
+            return new String(chars, beg, end - beg);
+        }
+
+        // gets hex string attribute value: "#" hexstring
+        private String hexAV() throws IOException {
+
+            if (pos + 4 >= length) {
+                // encoded byte array must be not less then 4 c
+                throw new IOException(ERROR_PARSE_ERROR);
+            }
+
+            beg = pos; // store '#' position
+            pos++;
+            while (true) {
+
+                // check for end of attribute value
+                // looks for space and component separators
+                if (pos == length || chars[pos] == '+' || chars[pos] == ','
+                        || chars[pos] == ';') {
+                    end = pos;
+                    break;
+                }
+
+                if (chars[pos] == ' ') {
+                    end = pos;
+                    pos++;
+                    // skip trailing space chars before comma or semicolon.
+                    // (compatibility with RFC 1779)
+                    for (; pos < length && chars[pos] == ' '; pos++) {
+                    }
+                    break;
+                } else if (chars[pos] >= 'A' && chars[pos] <= 'F') {
+                    chars[pos] += 32; // to low case
+                }
+
+                pos++;
+            }
+
+            // verify length of hex string
+            // encoded byte array must be not less then 4 and must be even
+            // number
+            int hexLen = end - beg; // skip first '#' char
+            if (hexLen < 5 || (hexLen & 1) == 0) {
+                throw new IOException(ERROR_PARSE_ERROR);
+            }
+
+            // get byte encoding from string representation
+            byte[] encoded = new byte[hexLen / 2];
+            for (int i = 0, p = beg + 1; i < encoded.length; p += 2, i++) {
+                encoded[i] = (byte) getByte(p);
+            }
+
+            return new String(chars, beg, hexLen);
+        }
+
+        // gets string attribute value: *( stringchar / pair )
+        private String escapedAV() throws IOException {
+
+            beg = pos;
+            end = pos;
+            while (true) {
+
+                if (pos >= length) {
+                    // the end of DN has been found
+                    return new String(chars, beg, end - beg);
+                }
+
+                switch (chars[pos]) {
+                case '+':
+                case ',':
+                case ';':
+                    // separator char has beed found
+                    return new String(chars, beg, end - beg);
+                case '\\':
+                    // escaped char
+                    chars[end++] = getEscaped();
+                    pos++;
+                    break;
+                case ' ':
+                    // need to figure out whether space defines
+                    // the end of attribute value or not
+                    cur = end;
+
+                    pos++;
+                    chars[end++] = ' ';
+
+                    for (; pos < length && chars[pos] == ' '; pos++) {
+                        chars[end++] = ' ';
+                    }
+                    if (pos == length || chars[pos] == ',' || chars[pos] == '+'
+                            || chars[pos] == ';') {
+                        // separator char or the end of DN has beed found
+                        return new String(chars, beg, cur - beg);
+                    }
+                    break;
+                default:
+                    chars[end++] = chars[pos];
+                    pos++;
+                }
+            }
+        }
+
+        // returns escaped char
+        private char getEscaped() throws IOException {
+
+            pos++;
+            if (pos == length) {
+                throw new IOException(ERROR_PARSE_ERROR);
+            }
+
+            switch (chars[pos]) {
+            case '"':
+            case '\\':
+            case ',':
+            case '=':
+            case '+':
+            case '<':
+            case '>':
+            case '#':
+            case ';':
+            case ' ':
+            case '*':
+            case '%':
+            case '_':
+                // FIXME: escaping is allowed only for leading or trailing space
+                // char
+                return chars[pos];
+            default:
+                // RFC doesn't explicitly say that escaped hex pair is
+                // interpreted as UTF-8 char. It only contains an example of
+                // such DN.
+                return getUTF8();
+            }
+        }
+
+        // decodes UTF-8 char
+        // see http://www.unicode.org for UTF-8 bit distribution table
+        private char getUTF8() throws IOException {
+
+            int res = getByte(pos);
+            pos++; // FIXME tmp
+
+            if (res < 128) { // one byte: 0-7F
+                return (char) res;
+            } else if (res >= 192 && res <= 247) {
+
+                int count;
+                if (res <= 223) { // two bytes: C0-DF
+                    count = 1;
+                    res = res & 0x1F;
+                } else if (res <= 239) { // three bytes: E0-EF
+                    count = 2;
+                    res = res & 0x0F;
+                } else { // four bytes: F0-F7
+                    count = 3;
+                    res = res & 0x07;
+                }
+
+                int b;
+                for (int i = 0; i < count; i++) {
+                    pos++;
+                    if (pos == length || chars[pos] != '\\') {
+                        return 0x3F; // FIXME failed to decode UTF-8 char -
+                                     // return '?'
+                    }
+                    pos++;
+
+                    b = getByte(pos);
+                    pos++; // FIXME tmp
+                    if ((b & 0xC0) != 0x80) {
+                        return 0x3F; // FIXME failed to decode UTF-8 char -
+                                     // return '?'
+                    }
+
+                    res = (res << 6) + (b & 0x3F);
+                }
+                return (char) res;
+            } else {
+                return 0x3F; // FIXME failed to decode UTF-8 char - return '?'
+            }
+        }
+
+        // Returns byte representation of a char pair
+        // The char pair is composed of DN char in
+        // specified 'position' and the next char
+        // According to BNF syntax:
+        // hexchar = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
+        // / "a" / "b" / "c" / "d" / "e" / "f"
+        private int getByte(int position) throws IOException {
+
+            if ((position + 1) >= length) {
+                // to avoid ArrayIndexOutOfBoundsException
+                throw new IOException(ERROR_PARSE_ERROR);
+            }
+
+            int b1, b2;
+
+            b1 = chars[position];
+            if (b1 >= '0' && b1 <= '9') {
+                b1 = b1 - '0';
+            } else if (b1 >= 'a' && b1 <= 'f') {
+                b1 = b1 - 87; // 87 = 'a' - 10
+            } else if (b1 >= 'A' && b1 <= 'F') {
+                b1 = b1 - 55; // 55 = 'A' - 10
+            } else {
+                throw new IOException(ERROR_PARSE_ERROR);
+            }
+
+            b2 = chars[position + 1];
+            if (b2 >= '0' && b2 <= '9') {
+                b2 = b2 - '0';
+            } else if (b2 >= 'a' && b2 <= 'f') {
+                b2 = b2 - 87; // 87 = 'a' - 10
+            } else if (b2 >= 'A' && b2 <= 'F') {
+                b2 = b2 - 55; // 55 = 'A' - 10
+            } else {
+                throw new IOException(ERROR_PARSE_ERROR);
+            }
+
+            return (b1 << 4) + b2;
+        }
+
+        /*
+         * Parses the DN and returns the attribute value for an attribute type.
+         *
+         * @param attributeType
+         *            attribute type to look for (e.g. "ca")
+         * @return value of the attribute that first found, or null if none
+         *         found
+         * @throws IOException
+         */
+        public String find(String attributeType) throws IOException {
+
+            // Initialize internal state.
+            pos = 0;
+            beg = 0;
+            end = 0;
+            cur = 0;
+            chars = dn.toCharArray();
+
+            String attType = nextAT();
+            if (attType == null) {
+                return null;
+            }
+            while (true) {
+                String attValue = "";
+
+                if (pos == length) {
+                    return null;
+                }
+
+                switch (chars[pos]) {
+                case '"':
+                    attValue = quotedAV();
+                    break;
+                case '#':
+                    attValue = hexAV();
+                    break;
+                case '+':
+                case ',':
+                case ';': // compatibility with RFC 1779: semicolon can separate
+                          // RDNs
+                    // empty attribute value
+                    break;
+                default:
+                    attValue = escapedAV();
+                }
+
+                if (attributeType.equalsIgnoreCase(attType)) {
+                    return attValue;
+                }
+
+                if (pos >= length) {
+                    return null;
+                }
+
+                if (chars[pos] == ',' || chars[pos] == ';') {
+                } else if (chars[pos] != '+') {
+                    throw new IOException(ERROR_PARSE_ERROR);
+                }
+
+                pos++;
+                attType = nextAT();
+                if (attType == null) {
+                    throw new IOException(ERROR_PARSE_ERROR);
+                }
+            }
+        }
+    }
 }
diff --git a/src/test/org/apache/commons/httpclient/TestAll.java b/src/test/org/apache/commons/httpclient/TestAll.java
index 053b148..974257d 100644
--- a/src/test/org/apache/commons/httpclient/TestAll.java
+++ b/src/test/org/apache/commons/httpclient/TestAll.java
@@ -31,6 +31,7 @@ package org.apache.commons.httpclient;
 import org.apache.commons.httpclient.auth.TestAuthAll;
 import org.apache.commons.httpclient.cookie.TestCookieAll;
 import org.apache.commons.httpclient.params.TestParamsAll;
+import org.apache.commons.httpclient.protocol.TestSSLProtocolSocketFactory;
 
 import junit.framework.*;
 
@@ -102,6 +103,7 @@ public class TestAll extends TestCase {
         suite.addTest(TestNoncompliant.suite());
         // Proxy
         suite.addTest(TestProxyWithRedirect.suite());
+        suite.addTestSuite(TestSSLProtocolSocketFactory.class);
         return suite;
     }
 
diff --git a/src/test/org/apache/commons/httpclient/protocol/TestSSLProtocolSocketFactory.java b/src/test/org/apache/commons/httpclient/protocol/TestSSLProtocolSocketFactory.java
new file mode 100644
index 0000000..95e6ea9
--- /dev/null
+++ b/src/test/org/apache/commons/httpclient/protocol/TestSSLProtocolSocketFactory.java
@@ -0,0 +1,51 @@
+package org.apache.commons.httpclient.protocol;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+import javax.net.ssl.SSLException;
+
+import junit.framework.TestCase;
+
+public class TestSSLProtocolSocketFactory extends TestCase {
+
+    private Method extractCNMethod;
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        Class<?> c = Class.forName("org.apache.commons.httpclient.protocol.SSLProtocolSocketFactory");
+        Method extractAllMethod = c.getDeclaredMethod("extractCN",new Class[] { String.class });
+        extractAllMethod.setAccessible(true);
+        this.extractCNMethod = extractAllMethod;
+    }
+
+    public void testExtractCN() throws Exception {
+        assertEquals("blah", extractCNMethod.invoke(null, "cn=blah, ou=blah, o=blah"));
+        assertEquals("blah", extractCNMethod.invoke(null, "cn=blah, cn=yada, cn=booh"));
+        assertEquals("blah", extractCNMethod.invoke(null, "c = pampa ,  cn  =    blah    , ou = blah , o = blah"));
+        assertEquals("blah", extractCNMethod.invoke(null, "cn=\"blah\", ou=blah, o=blah"));
+        assertEquals("blah  blah", extractCNMethod.invoke(null, "cn=\"blah  blah\", ou=blah, o=blah"));
+        assertEquals("blah, blah", extractCNMethod.invoke(null, "cn=\"blah, blah\", ou=blah, o=blah"));
+        assertEquals("blah, blah", extractCNMethod.invoke(null, "cn=blah\\, blah, ou=blah, o=blah"));
+        assertEquals("blah", extractCNMethod.invoke(null, "c = cn=uuh, cn=blah, ou=blah, o=blah"));
+        assertEquals("", extractCNMethod.invoke(null, "cn=   , ou=blah, o=blah"));
+    }
+
+    public void testExtractCNInvalid1() throws Throwable {
+        try {
+            assertEquals(null, extractCNMethod.invoke(null, "blah,blah"));
+            fail("should have thrown exception...");
+        } catch (InvocationTargetException ex) {
+            try {
+                throw ex.getCause();
+            } catch (SSLException e) {
+                assertEquals("blah,blah is not a valid X500 distinguished name", e.getMessage());
+            }
+        }
+    }
+
+    public void testExtractCNInvalid2() throws Exception {
+        assertEquals(null, extractCNMethod.invoke(null, "cn,o=blah"));
+    }
+}
\ No newline at end of file
-- 
1.9.3

